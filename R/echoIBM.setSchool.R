#*********************************************
#*********************************************
#' Returns a list of the following strings: (1) the path to the event, (2) the event name, (3) the event number, (4) the path to the cruise, and (5) the cruise name.
#'
#' @param event				A list of the following elements: (1) 'path', giving the paths to the sub-events, (2) 'esnm', giving the names of the acoustic instruments in the events (same length as 'path'), and (3) 'name', giving the name of the event.
#' @param surveyRegion		A data frame of two rows and the three columns x, y and z, defining the survey region.
#' @param target			A code word defining the target. One of "herring", "mackerel" and "point".
#' @param schools			A code word defining the distribution of schools. One of "layer", "uniform" (equal probability of encountering a school in all directions but the z direction, corresponding to a homogenious Poisson point process in the x-y-plane), "flat" (random ordering of schools sequenced between the survey bounds).
#' @param schoolSize		Definition of the school sizes, either given as a list of dimensions in the x, y and z direction (repeated to the number of schools), or a list of dimensions added a type of random generator for the sizes, such as type = "weibull", indicating correlated Weibull distributed sizes, where the shape and correlation are specified by 'shape' and 'cor'. Alternatively schoolSize can be a list to be used as input the a function schoolSize$type, which must be a function including the ... argument to avoid errors. For correlated Weibull distributed sizes use e.g. list(x = 100, y = 100, z = 20, type = "Weibull", shape = 5, cor = 0.4), where 0.4 is the maximum available correlation. For correlated uniform variables use e.g. list(x = c(30, 300), y = c(30, 300), z = c(30, 300) / 5, type = "Uniform", cor = 0.5), where 0.5 is the maximum available correlation. For schoolSize$type=="Uniform", if schoolSize$x is given as a single numeric, this is interpreted as uniform between 0 and 2 * x.
#' @param schoolDens		The area reserved for each school.
#' @param schoolDist		The mean distance betseen schools. Use rather schoolDens.
#' @param schoolCount		The number of schools.
#' @param fillSurveyRegion	Logical: If TRUE fill the survey region so that schools are generated also outside of the original survey region, elliminating edge effects in the spatial distribution of fish.	
#' @param seed				The seed of the school generation
#' @param depthRange		The depth range of the schools. Should be given in the \code{surveyRegion}.
#' @param onlyFirstEvent	Logical: If TRUE generate school files only for the first event (saving storage).
#' @param ...				Data overriding the variables generated by the funciton.
#'
#' @return
#'
#' @examples
#' \dontrun{}
#'
#' @importFrom TSD write.TSD
#' @importFrom utils head tail
#' @importFrom stats runif
#' @importFrom fields rdist
#'
#' @export
#' @rdname echoIBM.setup
#'

# 1. school size distribution + school density + packing density + school position distribution

echoIBM.setSchool <- function(
	event, 
	surveyRegion = NULL, 
	target = c("herring", "mackerel", "point"),
	schools = c("layer", "uniform", "flat"),
	schoolSize = list(x = 100, y = 100, z = 20, type = "Weibull", shape = 5, cor = 0.4), 
	schoolDens = 1852^-2, 
	schoolDist = NULL, 
	schoolCount = NULL, 
	fillSurveyRegion = TRUE, 
	seed = 0, 
	depthRange = c(-100, 0), 
	onlyFirstEvent = FALSE,
	...){
	
	############### LOG: ###############
	# Start: 2017-03-29 - Clean version.
	
	# Save the input variables:
	dotList <- list(...)
	
	vessel <- echoIBM.readFile(event$path[1], ext="vessel", t="all")
	beams <- lapply(event$path, echoIBM.readFile, ext="beams", t="all")
	files <- NULL
	
	
	############################################################
	############### (1) Generate static school data: ###########
	############################################################
	# Function used for generating the schools sizes:
	setSchoolSize <- function(schoolSize, schoolCount, seed=0){
		# Set the sizes of the schools:
		size0 <- matrix(unlist(lapply(schoolSize[c("x", "y", "z")], rep, length.out=schoolCount)), byrow=TRUE, ncol=3)
		if(strff("wei", schoolSize$type)){
			# Old comment: w=c(1) implies no correlation between schools:
			maxCorVec <- c(1, 0.6, 1, 0.6, 1)
			maxCor <- 0.4
			if(schoolSize$cor > maxCor){
				warning(paste0("Weibull distributed size cannot be correlated by more than ", maxCor, " (the correlation set to this value)"))
				schoolSize$cor <- maxCorVec
			}
			else{
				thismaxcor <- maxCorVec
				thismaxcor[2:4] <- thismaxcor[2:4] * schoolSize$cor / maxCor
				schoolSize$cor <- thismaxcor
			}
			size <- rexp_MultSines(J=schoolCount, I=3, L=3, N=40, P=10, w=1, olpn=schoolSize$cor, shape=schoolSize$shape[1], mean=size0, seed=seed)
		}
		else if(strff("uni", schoolSize$type)){
			maxCor <- 0.5
			if(schoolSize$cor > maxCor){
				warning(paste0("Uniformly distributed size cannot be correlated by more than ", maxCor, " (the correlation set to this value)"))
				schoolSize$cor <- maxCor
			}
			cor1 <- (schoolSize$cor / maxCor)^2 * maxCor
			
			
			
			# Set the weights in the sums below (here the multiplication with sqrt(2) is to normalize to the standard deviation of the sum of two ):
			
			
			# Draw Gaussian variables, and map back to uniform using pnorm():
			set.seed(seed)
			n1 <- rnorm(schoolCount)
			n2 <- rnorm(schoolCount)
			n3 <- rnorm(schoolCount)
			x <- cor1 * n1 + maxCor * n2
			y <- cor1 * n2 + maxCor * n3
			z <- cor1 * n3 + maxCor * n1
			sd <- sqrt(cor1^2 + maxCor^2)
			size <- cbind(pnorm(x, sd=sd), pnorm(y, sd=sd), pnorm(z, sd=sd))
			# Add the sizes:
			if(length(schoolSize$x)==0){
				schoolSize$x <- c(0, 2 * schoolSize$x)
			}
			if(length(schoolSize$y)==0){
				schoolSize$y <- c(0, 2 * schoolSize$y)
			}
			if(length(schoolSize$z)==0){
				schoolSize$z <- c(0, 2 * schoolSize$z)
			}
			size[, 1] <- schoolSize$x[1] + diff(schoolSize$x) * size[, 1]
			size[, 2] <- schoolSize$y[1] + diff(schoolSize$y) * size[, 2]
			size[, 3] <- schoolSize$z[1] + diff(schoolSize$z) * size[, 3]
		}
		else if(is.function(schoolSize$type)){
			size <- do.call(schoolSize$type, schoolSize)
		}
		else{
			size <- size0
		}
		size
	}
	
	# Apply default settings specified by 'target':
	# Herring:
	if(tolower(head(target, 1)) == "herring"){
		schoolStatic <- list(
			pbpf = "pr",
			obln = 5,
			tilt = 0, 
			# Define compression of the swim bladder in case the simulate targets have one (defaults taken from Ona 2003, with compression only radially in the swim bladder):
			gamw = -0.23,
			gaml = 0, 
			# Ratio of swim bladder versus total length (Gorska and Ona 2003, Modelling the effect of swimbladder compression on the acoustic backscattering from herring at normal or near-normal dorsal incidences).
			zeta = 0.26,
			# The backscattering coefficient of each individual target can be given directly through the sgbs variable:
			sgbs = NULL,
			# Otherwise use the link between fish size and sgbs:
			epss = function(f){
				10^(-6.54)*100^2 * (f/38000)^(-0.4)
			}
			)
		schoolDynamic <- list(
			MEsz = 0.32,
			SDsz = 0.02,
			PDsz = "rnorm"
			)
	}
	else if(tolower(head(target, 1)) == "mackerel"){
		schoolStatic <- list(
			pbpf = "pr",
			obln = 5,
			tilt = 0, 
			# Define compression of the swim bladder in case the simulate targets have one (defaults taken from Ona 2003, with compression only radially in the swim bladder):
			gamw = 0,
			gaml = 0, 
			# Ratio of swim bladder versus total length, set to 1 when no swimbladder:
			zeta = 1,
			# The backscattering coefficient of each individual target can be given directly through the sgbs variable:
			sgbs = NULL,
			# Otherwise use the link between fish size and sgbs:
			epss = function(f){
				NA
			}
			)
		schoolDynamic <- list(
			MEsz = 0.32,
			SDsz = 0.02,
			PDsz = "rnorm"
			)
	}
	else if(tolower(head(target, 1)) == "point"){
		schoolStatic <- list(
			pbpf = "ps",
			obln = 1,
			tilt = 0, 
			# Define compression of the swim bladder in case the simulate targets have one (defaults taken from Ona 2003, with compression only radially in the swim bladder):
			gamw = 0,
			gaml = 0, 
			# Gorska and Ona 2003, Modelling the effect of swimbladder compression on the acoustic backscattering from herring at normal or near-normal dorsal incidences.
			zeta = 1,
			# The backscattering coefficient of each individual target can be given directly through the sgbs variable:
			sgbs = NULL,
			# Otherwise use the link between fish size and sgbs:
			epss = function(f){
				10^(-6.54)*100^2 * (f/38000)^(-0.4)
			}
			)
		schoolDynamic <- list(
			MEsz = 0.32,
			SDsz = 0,
			PDsz = "rnorm"
			)
	}
	
	# If prolate spheroid is given for the parametric beam pattern of the targets, include the beam pattern file of the given aspect ratio:
	if(schoolStatic$pbpf == "pr"){
		targetBeamPatternFiles <- list.files(system.file("extdata", "TargetBeamPattern", package="echoIBM"), full.names=TRUE)
		# Split the basenames by "_": 
		targetBeamPatternbasenameSplitted <- strsplit(basename(targetBeamPatternFiles), "_")
		obln <- as.numeric(sapply(targetBeamPatternbasenameSplitted, function(x) x[which(tolower(x)=="obln")[1] + 1]))
		selected <- which.min(abs(obln - schoolStatic$obln))
		if(obln[selected] != schoolStatic$obln){
			warning(paste0("The target beam pattern file of the closest oblongness chosen (", targetBeamPatternFiles[selected], ")"))
		}
		
		beampatternfiles <- file.path(event$path, basename(targetBeamPatternFiles[selected]))
		lapply(beampatternfiles, function(thispath) file.copy(targetBeamPatternFiles[selected], thispath))
		# Add the file names to the output:
		names(beampatternfiles) <- event$esnm
		files <- c(files, beampatternfiles)
	}
		
	# Add data:
	schoolStatic <- replaceKeepDim(schoolStatic, dotList, esnm="")
	
	# Write the static school file to the events:
	schoolStaticFiles <- file.path(event$path, paste0(event$name, "_SchoolStatic", ".school"))
	if(onlyFirstEvent){
		schoolStaticFiles <- schoolStaticFiles[1]
	}
	lapply(schoolStaticFiles, function(thispath) write.TSD(schoolStatic, thispath, numt=1))
	# Add the file names to the output:
	names(schoolStaticFiles) <- event$esnm
	files <- c(files, schoolStaticFiles)
	#lapply(if(onlyFirstEvent) event$path[1] else event$path, function(thispath) write.TSD(schoolStatic, file.path(thispath, paste0(event$name, "_SchoolStatic", ".school")), numt=1))
	############################################################
	############################################################
	
	
	############################################################
	############## (2) Generate dynamic school data: ###########
	############################################################
	# Get total rectangular survey region:
	if(length(surveyRegion)==0){
		surveyRegion <- data.frame(x=range(vessel$psxv), y=range(vessel$psyv))
		# Add the echosounder/sonar range:
		getmxrb <- function(x){
			if(length(x$rres)==0){
				x$rres <- x$sint * x$asps / 2
			}
			# (changed on 2017-12-08 from simply the maximum range to the maximum HORIZONTAL range)
			#max(x$lenb * matrix(x$rres, ncol=NCOL(x$lenb), nrow=NROW(x$lenb)))
			max(x$lenb * matrix(x$rres, ncol=NCOL(x$lenb), nrow=NROW(x$lenb))) * max(sin(x$dire))
		}
		mxrb <- max(unlist(lapply(beams, getmxrb)))
		# Add the maximum horizontal range:
		surveyRegion <- surveyRegion + c(-1, 1) * mxrb
	}
	if(length(surveyRegion$z)==0){
		surveyRegion$z <- range(depthRange)
	}
	
	# Set the seed. This is a simple solution, fragile for changes in the code:
	set.seed(seed)
	
	
	# Special case if a layer of fish is requsted. In that case rectangular schools are defined and positioned on a grid, so that the entire observation region is filled:
	if(tolower(head(schools, 1)) == "layer"){
		# Divide the survey region into rectangles with sizes given by 'schoolSize':
		gridx <- seq(surveyRegion$x[1], surveyRegion$x[2], schoolSize$x[1])
		if(tail(gridx, 1) < surveyRegion$x[2]){
			gridx <- c(gridx, surveyRegion$x[2])
		}
		gridy <- seq(surveyRegion$y[1], surveyRegion$y[2], schoolSize$y[1])
		if(tail(gridy, 1) < surveyRegion$y[2]){
			gridy <- c(gridy, surveyRegion$y[2])
		}
		# Get mid points and sizes from the grid:
		midgridx <- (gridx[-1] + gridx[-length(gridx)]) / 2
		midgridy <- (gridy[-1] + gridy[-length(gridy)]) / 2
		midgridz <- mean(surveyRegion$z[1:2])
		midgrid <- expand.grid(midgridx, midgridy, midgridz)
		schoolCount <- nrow(midgrid)
		sizex <- diff(gridx)
		sizey <- diff(gridy)
		sizez <- diff(surveyRegion$z[1:2])
		size <- expand.grid(sizex, sizey, sizez)
		
		
		### (1) Position: 
		# Layer block positions:
		psxS <- midgrid[,1]
		psyS <- midgrid[,2]
		pszS <- midgrid[,3]
		
		### (2) Size: 
		# Layer block sizes:
		szxS <- size[,1]
		szyS <- size[,2]
		szzS <- size[,3]
		
		### (3) Shape: 
		# Use rectangular shaped "schools" for the layer:	 
		shpS <- "r"
		
		### (4) Direction: 
		# Random orientation of the school (including the fish):
		thtS <- runif(schoolCount, 0, 2*pi)
		phiS <- pi/2
		
		### (5) Rotation: 
		# Layer block rotations (no rotation):
		rtxS <- 0
		rtyS <- 0 
		rtzS <- 0 
		
		### (6) Speed: 
		# No speed:
		aspS <- 0
		
		### (7) Packing density: 
		rhoS <- 1
		
		### (8) Polarization: 
		# SD of mean 0-Gaussian distribution of individual fish positions:
		#SDxf <- 1
		#SDxf <- 1
		#SDxf <- 1 
		# No polarization:
		plHS <- Inf
		
		### (9) Drift: 
		# No drift:
		
		### (10) Volume: 
		# Add volS also as a global variable for use in nbfS. Volume 'volS' is only used to derive the approximate memory used:
		volS <- szxS * szyS * szzS
		vol0 <- volS
		nbfS <- rhoS * volS
		
		
		# Add the data into the schoolDynamic:
		schoolDynamic <- c(
			schoolDynamic, 
			list(
				# (1) Position: 
				psxS = psxS,
				psyS = psyS,
				pszS = pszS,
				# (2) Size: 
				szxS = szxS,
				szyS = szyS,
				szzS = szzS,
				# (3) Shape: 
				shpS = shpS,
				# (4) Direction: 
				thtS = thtS,
				phiS = phiS,
				# (5) Rotation: 
				rtxS = rtxS,
				rtyS = rtyS,
				rtzS = rtzS,
				# (6) Speed: 
				aspS = aspS,
				# (7) Packing density: 
				rhoS = rhoS,
				# (8) Polarization: 
				plHS = plHS,
				# (9) Drift: 
				# (10) Volume: 
				volS = volS,
				nbfS = nbfS
			)
		)
	}
	# Uniformly distributed schools:
	else if(tolower(head(schools, 1)) %in% c("uniform", "flat")){
		
		# If the school density is given, calculate the number of schols:
		if(length(schoolCount)==0){
			schoolCount <- round(diff(surveyRegion$x) * diff(surveyRegion$y) * if(length(schoolDist)) schoolDist^2 else schoolDens)
		}
		
		# Set the sizes of the schools:
		size <- setSchoolSize(schoolSize, schoolCount, seed)
		maxSize <- apply(size, 2, max)
	
		# Add half of the maximum school size on all sides of the surevy region:
		if(fillSurveyRegion){
			oldSurveyRegion <- surveyRegion
			surveyRegion[1, ] <- surveyRegion[1, ] - maxSize/2
			surveyRegion[2, ] <- surveyRegion[2, ] + maxSize/2
			
			oldArea <- prod(apply(oldSurveyRegion[,1:2], 2, diff)) 
			newArea <- prod(apply(surveyRegion[,1:2], 2, diff)) 
			newSchoolCount <- round(schoolCount * newArea / oldArea)
			if(newSchoolCount > schoolCount){
				cat("Number of schools changed from ", schoolCount, " to ", newSchoolCount, "\n")
				schoolCount <- newSchoolCount
			}
		}
		
		# Update the sizes of the schools:
		size <- setSchoolSize(schoolSize, schoolCount, seed)
		
	
		### (1) Position: 
		# Generate the school positions:
		if(tolower(head(schools, 1)) == "uniform"){
			# Set the positions of the schools as uniformly distributed in x, y and z dimension:
			psxS <- runif(schoolCount, surveyRegion$x[1], surveyRegion$x[2])
			psyS <- runif(schoolCount, surveyRegion$y[1], surveyRegion$y[2])
			pszS <- runif(schoolCount, surveyRegion$z[1], surveyRegion$z[2])
		}
		else if(tolower(head(schools, 1)) == "flat"){
			# Position school on a sequence between the survey region bounds:
			#margin <- diff(surveyRegion$x)/schoolCount/2
			#psxS <- seq(surveyRegion$x[1] + margin, surveyRegion$x[2] - margin, length.out=schoolCount)
			#margin <- diff(surveyRegion$y)/schoolCount/2
			#psyS <- seq(surveyRegion$y[1] + margin, surveyRegion$y[2] - margin, length.out=schoolCount)
			psxS <- seq(surveyRegion$x[1], surveyRegion$x[2], length.out=schoolCount)
			psyS <- seq(surveyRegion$y[1], surveyRegion$y[2], length.out=schoolCount)
			pszS <- seq(surveyRegion$z[1], surveyRegion$z[2], length.out=schoolCount)
			# Then resample:
			if(length(psxS)>1){
				psxS <- sample(psxS)
				psyS <- sample(psyS)
				pszS <- sample(pszS)
			}
		}
		
		ord <- order(psxS, psyS, pszS)
		psxS <- psxS[ord]
		psyS <- psyS[ord]
		pszS <- pszS[ord]
		
		### (2) Size: 
		# School sizes are defined above:
		szxS <- size[,1]
		szyS <- size[,2]
		szzS <- size[,3]
		
		### (3) Shape: 
		# Use rectangular shaped "schools" for the layer:	 
		shpS <- "e"
		
		### (4) Direction: 
		# Random orientation of the school (including the fish):
		thtS <- runif(schoolCount, 0, 2*pi)
		phiS <- pi/2
		
		### (5) Rotation: 
		# School rotations (no rotation):
		rtxS <- 0
		rtyS <- 0 
		rtzS <- 0 
		
		### (6) Speed: 
		# No speed:
		aspS <- 0
		
		### (7) Packing density: 
		rhoS <- 1
		
		### (8) Polarization: 
		# SD of mean 0-Gaussian distribution of individual fish positions:
		#SDxf <- 1,
		#SDxf <- 1,
		#SDxf <- 1, 
		# No polarization:
		plHS <- Inf
		
		### (9) Drift: 
		# No drift:
		
		### (10) Volume: 
		###volS = volS <- 4/3*pi * schools$szxS/2 * schools$szyS/2 * schools$szzS/2
		# Ellipsoidal schools (http://keisan.casio.com/has10/SpecExec.cgi?path=05000000.Mathematics%2F01000300.Volume%20and%20surface%20area%2F13000700.Volume%20of%20an%20ellipsoidal%20cap%2Fdefault.xml&charset=utf-8):
		##axA <- schools$szxS/2
		##axB <- schools$szyS/2
		##axC <- schools$szzS/2
		##below <- schools$pszS - axC
		### Add volS also as a global variable for use in nbfS. Volume 'volS' is only used to derive the approximate memory used:
		##volS = volS <- pi/3 * axA*axB * below^2/axC^2 * (3*axC - below)
		##vol0 <- 4*pi/3 * axA * axB * axC
		
		axA <- szxS/2
		axB <- szyS/2
		axC <- szzS/2
		below <- axC - pszS
		# For fully submerged schools the height below is set to the heigth of the school:
		below[below > szzS] <- szzS[below > szzS]
		below[below < 0] <- 0
		volS <- pi/3 * axA * axB * below^2/axC^2 * (3*axC - below)
		vol0 <- 4*pi/3 * axA * axB * axC
		nbfS <- rhoS * volS
		
		# Add the data into the schoolDynamic:
		schoolDynamic <- c(
			schoolDynamic, 
			list(
				# (1) Position: 
				psxS = psxS,
				psyS = psyS,
				pszS = pszS,
				# (2) Size: 
				szxS = szxS,
				szyS = szyS,
				szzS = szzS,
				# (3) Shape: 
				shpS = shpS,
				# (4) Direction: 
				thtS = thtS,
				phiS = phiS,
				# (5) Rotation: 
				rtxS = rtxS,
				rtyS = rtyS,
				rtzS = rtzS,
				# (6) Speed: 
				aspS = aspS,
				# (7) Packing density: 
				rhoS = rhoS,
				# (8) Polarization: 
				plHS = plHS,
				# (9) Drift: 
				# (10) Volume: 
				volS = volS,
				vol0 = vol0,
				nbfS = nbfS
			)
		)
	}
	else{
		stop(paste0("School type ", tolower(head(schools, 1)), " not implemented"))
	}
	
	schoolDynamic$scls <- 1
	
	# Pick the start time of the simulation project as the time of all of the schools:
	schoolDynamic$utmS <- rep(head(vessel$utim, 1), schoolCount)
	schoolDynamic$ut9S <- rep(Inf, schoolCount)
	
	# Repeat to apropriate length:
	#allNumt <- unlist(lapply(schoolDynamic, NCOL))
	#maxnumt <- max(allNumt)
	#allSchoolCount <- unlist(lapply(schoolDynamic, NROW))
	#schoolCount <- max(allSchoolCount)
	
	# Discard empty elements:
	#schoolDynamic <- schoolDynamic[sapply(schoolDynamic, length)>0]
	#
	#if(!all(allNumt==maxnumt)){
	#	schoolDynamic <- lapply(schoolDynamic, apply, 1, rep, length.out=maxnumt)
	#}
	#if(!all(allSchoolCount==schoolCount)){
	#	schoolDynamic <- lapply(schoolDynamic, apply, 2, rep, length.out=schoolCount)
	#}
	
	maxlength <- max(unlist(lapply(schoolDynamic, length)))
	schoolDynamic <- lapply(schoolDynamic, rep, length.out=maxlength)
	
	# Add data:
	schoolDynamic <- replaceKeepDim(schoolDynamic, dotList, esnm="")
	
	# Calculate the distances to the schools, and find the time steps which are closest, and the distance at those time steps:
	d <- fields::rdist(cbind(vessel$psxv, vessel$psyv, vessel$pszv), cbind(schoolDynamic$psxS, schoolDynamic$psyS, schoolDynamic$pszS))
	schoolDynamic$dstc <- apply(d, 2, min)
	schoolDynamic$timc <- apply(d, 2, which.min)
	
	# Write the static school file to the events:
	#lapply(if(onlyFirstEvent) event$path[1] else event$path, function(thispath) write.TSD(schoolDynamic, file.path(thispath, paste0(event$name, "_SchoolDynamic", ".school")), numt=ncol(schoolDynamic$psxS)))
	schoolDynamicFiles <- file.path(event$path, paste0(event$name, "_SchoolDynamic", ".school"))
	if(onlyFirstEvent){
		schoolDynamicFiles <- schoolDynamicFiles[1]
	}
	lapply(schoolDynamicFiles, function(thispath) write.TSD(schoolDynamic, thispath, numt=1))
	
	# Add the file names to the output:
	names(schoolDynamicFiles) <- event$esnm
	files <- c(files, schoolDynamicFiles)
	return(files)
}
